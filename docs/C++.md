---
sidebar: auto
---

# C++

### 题型

| 题型       | 数量 | 小题分值                   | 总分 |
| ---------- | ---- | -------------------------- | ---- |
| 选择题     | 20   | 1                          | 20   |
| 填空题     | 15   | 1                          | 15   |
| 程序填空题 | 5    | 4/2(每题两个空)            | 20   |
| 程序分析题 | 5    | 6                          | 30   |
| 程序设计   | 2    | 5/10 一道题5分、一道题10分 | 15   |



1. 单项选择
2. 填空
3. 程序填空
4. 程序分析题
5. 程序设计题

## 第一章 C++语言简介

### C++语言的发展简史

没啥说的

### C++语言特点

#### 一、基本的输入/输出

`cin>>a`

`cout<<a`

`count<<endl`

#### 二、头文件和命名空间

##### 头文件

`##include<iostream>`

##### 命名空间

` using namespace std`

#### 三、强制类型转换运算符

1. 将一种数据类型转换成另一种数据类型

`stati_cast<类型名>(表达式)`

``` c++
stati_cast; //可以省略不写
oneint2 = static_cast<int>(oneDouble);
oneint2=int(oneDouble)
oneint2=(int)oneDouble//圆括号
oneint2=oneDouble//(自动)
```

2. 功能：将常量指针转化成非常量的指针，并且仍然指问原来的对象；或是将常量引用转换成非常量的引用，并且仍然指向原来的对象。
   ```
   int a=10,*q;const int ca=30;
   const int*p=&a;//不能使用常量指针p修改a的值
   q=const_cast<int*>(p)/不能q=p
   *q=20
   //变量a的值变为20，不能形成*p=20
   p=&ca;/ca的值不能修改
   ```

#### 四、函数参数的默认值

1. 在声明函数为形参指定默认值 
2. 只能为函数最后面的连续若干个参数设置默认值，且在调用处也只能缺省后面的连续若干个实参
3. 在函数调用处只能雀圣后面的连续若干个实参，而且所有缺省的实参必须已经有默认值
4. 不仅可以使用常数，还可用有定义的表达式作为参数的默认值
5. 注意：函数参数的默认值可以写在声明函数的地方，也可以写在定义函数的地方，但不能在两个地方都写。

#### 五、引用和函数参数的传递

1. 引用相当于给变量起了一个别名，别名的地址与引用的变量地址是一样的。程序中使用哪个名字都是允许的
   1. 不能通过常引用去修改其引用的变量的值
2. 引用在函数中使用
   ◆引用作为函数的参数数
   在函数在C+中，函数调用时参数的传递有两种方式：传值和传引用。传引用是传递对象的首地址值，形参的改变就意味着实参的改变。

#### 六、const与指针共同使用

1. 1如果唯一的cost位于符号*的左侧，表示指针所指数据是常量，数据不能通过本指针改变，但可以通过其他方式进行修改；指针本身是变量，可以指向其他的内存单元。

   ```c++
   int a1=10,a2=20,*pa1=&a1;
   *pa1=30;//正确，a1变成10
   const int*pa2=&a2;//pa2所指的是常量，pa2是
   *pa2=40;//错误
   pa2=&a1;//正确
   
   ```

   

2. 如果唯一的const位于符号*的右侧，表示指针本身是常量，不能让该指针指向其他内存地址；指针所指的数
   据可以通过本指针进行修改。

   ```c++
   int a1=10,a2=20;
   int*const pa2=&a2;//指针变量pa2是常量
   pa2=&a1;//错误
   *pa2=40;//正确
   ```

3. 在符号*的左右各有一个const时，表示指针和指针所指数据都是常量，既不能让指针指向其他地址，也不能
   通过指针修改所指向的内容。

   ```c++
   inta1=10,a2=20;
   const int*const pa1=&a1;//数据和指针都是常量
   pa1=&a2;//错误
   *pa1=30;//错误
   int const*const pa2=&a2;//数据和指针都是常量
   pa2=&a1;//错误
   *pa2=40;//错误
   ```

4. 记住const的修饰规则：const修饰其左侧的内容；如果const是本行的第一个标识符，则它修饰其右侧的内容。

   ```c++
   const int*pa2=&a2;//pa2所指的是常量
   int*const pa2=&a2;//指针变量pa2是常量
   const int*const pa1=&a1;//数据和指针都是常量
   int const*const pa.2=&a2;//数据和指针都是常量
   ```

#### 七、内联函数

1. 对于需要频繁调用，且代码量少的函数，可以将其定义为内联函数。编译时，编译程序将整个函数体的代码复
   制到调用该函数的位置。
   定义内联函数的格式如下：
   inl ine返回值类型函数名（形参表）
   {函数体}
   如果函数体中有循环语句和switch语句则通常不定义为内联函数。

#### 八、函数的重载

就是一个函数名 函数的参数不一样 有好几个这样的函数 java的重载懂不？

#### 九、指针和动态内存分配

1. 指针：即指针变量，该变量储存的是一个地址，是该指针所指对象的首地址。

```c++
int a=100,*pa=&a;
int s[10],ps=s;
//指针ps指向数组s的首地址
```

2. 动态内存分配
   动态分配内存一般格式为：
   指针名=new类型名；//分配
   delete指针名；//释放
   当不再使用这个空间时，必须使用delete释放空间。若使用new运算符动态分配了一个数组，那么释放该数组时，语句如下：delete[]指针。

3. ```c++
   ##include <iostream>
   using namespace std;
   int main(){
       double* p;//声明double型指针
       p = new double[3];//分配3个double型数据的存储空间
       for (int i = 0; i < 3; i++)//定义对象的初值为0
           cin >> *(p + i);//将输入数据存入指定地址
       for (int j = 0; j < 3; j++)
           cout << *(p + j) << " ";//将地址里的内容输出
       delete p;//释放空间
   }
   ```

#### 十、用string对象处理字符串

C语言用字符数组来处理字符串，C++提供string数据类型来处理符串。

1. 声明string对象
   ```c++
   	string strl;//声明string对象strl,值为空
   	string city = "Beijing";// 声明string对象并初始化
   	string str2 = city;// 使用字符串变量进行初始化
   	char name[] = "C++程序";
   	string str3 = name;// 使用字符数组对string变量进行初
   	string citysf0[] = { "Beijing","Shanghai","Tianjing" };//声明string对象数组，每个数组元素都是字符串
   ```

   1. 说明：
      1. 使用string对象，必须 `##include<string>`;
      2. string对象储存的是字符串的首地址，非字符串本身；sizeof(string)在32位的DevC++中是4，在64位的DevC+中是8。

2. string对象的操作

   1. string对象可以使用cin和cout进行输入和输出

      ```c++
      string si, s2;
      cin >> sl >> s2;
      cout << sl << ","H << s2 << endl;
      ```

   2. string对象之间可以互相赋值，也可以用字符串常量和字符数组的名字对string对象进行赋值。

      ```c++
      string s1,s2="OK";
      s1="China";
      s2=s1;//赋值后s2的内容和s1相同
      ```

3. string对象之间可以用">",">=","==","<=","<","!="运算符进行比较大小。大小的判定标准是按照字典顺序进行的，而且是大小写相关的

   ```c++
   bool b //c++新增了bool类型，该类型只有两个值 1或0 ， 1代表真，0代表假
   
   string s1 = "China",s2 = "OK";
   
   b=s1>s2;//变量b的值为0
   ```

   

### C++语言的程序结构

1. .cpp文件扩展名 文件中包含若干各类和若干个函数
2. 程序仅有一个主函数mai()程序从主函数的开始处执行，在主函数结束

​	程序的结束通常是遇到了以下两种情形之一

​		在主函数遇到了return语句

​		执行到了主函数最后面的大括号

3. 主函数可以调用其他函数，其他函数互相可以调用，其他函数不能调用主函数
4. 注释 // /**/

## 第二章 面向对象的基本概念

### 考核目标

1. 了解传统结构化程序设计的不足，初步理解面向对象程序设计思想、概念和特点
2. 熟悉类的定义和使用方式
3. 通过示例程序剖析对象，理解类成员可访问的范围

### 第一节 结构化设计

1. 结构化程序设计的基本方法：采用自顶向下、逐步求精及模块化的思想，将复杂的大问题层层分解为许多简单的小问题。
2. 结构化程序设计的三种基本结构：顺序结构、选择结构、循环结构。
3. 结构化程序设计的基本思想：
   数据结构+算法=程序
4. 结构化程序设计的缺点：程序在代码规模庞大时，变得难以理解、难以扩充、难以查错和难以复用。
5. 这种情况下，面向对象的程序设计方法就应运而生了

### 第二节 面向对象设计的概念和特点

#### 一、面向对象思想的提出

1. 面向对象程序设计方法是20世纪90年代以来软件开发方法的主流，它继承了结构化程序设计方法的优点，
   同时又比较有效地改善了结构化程序设计的不足。
2. 面向对象的程序设计方法：使分析、设计和实现一个系统的方法尽可能地接近人们认识一个系统的方法。通常包括3个方面：面向对象的分析、面向对象的设计和面向对象的程序设计。
3. 面向对象技术把问题看成是对象的集合。对象具有两个特性：一是对象本身的信息，也称为属性；一是对
   对象的操作，也称为行为。
4. 对象=数据（属性)+函数（行为)。
5. 类是对象的一个抽象。

### 二、面向对象程序设计的特点

面向对象程序设计的四个基本特点：抽象、封装、继承和多态。

1. 抽象：将同一类事物的共同特点概括出来，这个过程就叫作“抽象”
   1. 类是对现实世界中客观事物的抽象。对于一个具体的类，它有许多具体的个体，这些个体叫做“对象”
   2. 对象是系统中用来描述客观事物的一个实体，用对象名、属性和操作三要素来描述对象。
   3. 描述属性的数据称为成员变量或数据成员，对这组属性进行操作的函数称为成员函数。对象由数据成员和成员
      函数构成。

2. 封装：就是把对象的属性和操作结合成一个独立的单元。
   封装作用：
   1. 数据和操作数据的函数紧密联系起来；
   2. 将对象的一部分属性和函数隐藏起来，让这部分属性和函数对外不可见，起到保护作用。
   3. 另一些属性和函数对外可见，作为对对象进行操作的接口
3. 继承：在编写一个“新”类的时候，以现有的类作为基础，使得新类从现有的类“派生”而来，从而达到代码扩充和代码复用的目的。
4. 多态：不同的对象可以调用相同名称的函数，但可导致完全不同的行为的现象称为多态性。利用多态性，程序中只需进行一般形式的函数调用，函数的实现细节留给接受函数调用的对象，这大大提高了人们解决复杂问题的能力。

### 第三节 类的初步知识

#### 一、类的定义

1. 类的基本概念

   1. 类是具有相同的属性和操作的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内包括属性（数据变量）和操作（成员函数）两个主要部分。
   2. 类是一种用户自己构造的数据类型；
   3. 类要先声明后使用、是具有唯一标识符的实体；

2. 声明类

   C++中声明类的一般形式为：
   class类名{
   	private:
   		私有变量和函数
   	public:
   		公有变量和函数
   	protected:
   		保护变量和函数
   };

   说明：

   ①private是完全私有的，只有本类内可以访问，派生类和外部都不可以访问；
   ②protected是受保护的，只有本类内和派生类可以访问，外部不能访问；
   ③public内、外部都能访问；
   ④如无访问权限的关键字，则默认声明为private;
   ⑤不能在类的声明中对数据变量进行初始化；
   ⑥类声明中可以给出成员函数的参数的默认值；
   ⑦类中声明的任何成员不能使用extern、auto和register关键字修饰；
   ⑧类中可以不含有任何成员变量和成员函数，这样的类称为空类。

   【例】描述点的Point类

   ```c++
   class Point {					//class是定义类的关键字，Point是类名
   private:						// 声明为私有访问权限
   	int x, y;					// 私有数据成员
   public:							// 声明为公有访问权限
   	void Setxy(int a, int b);	//声明无返回值的公有成员函数
   	void Move(int a, int b);	// 声明无返回值的公有成员函数
   	void Disp();				// 声明无返回值的公有成员函数
   	int Getx();					// 声明返回值为int的公有成员函数
   	int Gety();					// 声明返回值为int的公有成员函数
   
   };
   ```

3. 定义成员函数

   返回值类型 类名：成员函数名（形参列表）
   {成员函数的函数体
   }
   说明：
   ①返回类型是指这个成员函数返回值的类型；
   ②类名是指成员函数所属类的名字；

   ③“::”是作用域运算符，用于表示其后的成员函数属于这个特定的类；
   例：定义属于Point类的成员函数Setxy
   void Point:Setxy(int a,int b)
   {x=a;y=b;}
   ④类中定义的成员函数允许重载。

   ⑤可以使用关键字inline>将成员函数定义为内联函数（凡是出现调用该函数的地方，编译程序自动将其转换为该函数的函数体，不再在程序执行时调用该函数，大大提高了效率)。
   如：inline int Point:Getx()
   {return x;}
   ⑥如果在声明类的同时，在类体内给出成员函数的定义，就默认为内联函数，如将声明Getx()的语句“int Getx();改为“int Getx（)
   {return x;}”,则Getx为内联函数。

   ```C++
   class myDate {
   public:
   	myDate();					//构造函数
   	myDate(int, int, int);		//构造函数
   	void setDate(int, int, int);//设置日期
   	void setDate(myDate);		//设置日期
   	myDate getDate();			//获取日期
   	void setYear(int);			//设置年
   	int getMonth();				//获取月
   	void getDay();				//获取日
   	void printDate() const;		//打印日期
   private:
   	int year, month, day;		//成员变量
   };
   
   myDate::myDate() {							//构造函数用来初始化
   	year = 170,month = 1,day = 1;
   }
   myDate::myDate(int y, int m, int d) {		//构造函数
   	year = y, month = m, day = d;
   }
   void myDate::setDate(int y, int m, int d) { //用变量设置日期
   	year = y, month = m, day = d;
   	return;
   }
   void myDate::setDate(myDate oneD) {			//用对象设置日
   	year = oneD.year, month = oneD.month, day = oneD.day;
   	return;
   }
   myDate myDate::getDate() {					//获取日期
   	return *this;
   }
   void myDate::setYear(int y) {				//设置年
   	year = y;
   	return;
   }
   int myDate::getMonth() {					//获取月
   	return month;
   }
   void myDate::printDate() const {			//打印日期
   	cout << year << "/" << month << "/" << day;
   	return;
   }
   ```

   ```c++
   class Student {
   public:
   	void setStudent(string, myDate);	// 设置学生信息
   	void setName(string);				// 设置姓名
   	string getName();					// 获取姓名
   	void setBirthday(myDate);			// 设置生日
   	myDate getBirthday();				// 获取生日
   	void printStudent()const;			// 打印信息
   private:
   	string name;						// 姓名
   	myDate birthday;					// 生日
   };										//string系统定义好的类，myDate前面例题定义的类
   // 在类体外定义成员函数
   void Student::setStudent(string s, myDate d) { //设置学生信息
   	name = s;
   	birthday.setDate(d);
   	return;
   }
   void Student::setName(string n) {			// 设置姓名
   	name = n;
   	return;
   }
   string Student::getName() {					// 获取姓名
   	return name;
   }
   ```

   

### 第四节 类的示例程序剖析

#### 一、程序结构

一个完整的C++程序包括以下几部分。

1. 一个主函数，可以调用其他函数，但不能被调用，也称为主程序。
2. 用户定义的任意多个的类及全局函数。全局说明。在所有函数和类定义之外的变量说明及函数原型。
3. 注释。
4. 头文件。

#### 二、成员变量与成员函数的定义

1. 成员变量：一般均定义为私有访问权限，这样的成员仅能在本类内访问。类外需要通过访问本类函数来访问私有的成员变量。
2. 成员函数的定义
   返回值类型 类名::成员函数名（形参列表）
   函数体
   }

#### 三、创建类对象的基本形式

1. 定义一个普通对象，即类变量的基本方法有两种

   1. 类名 对象名

      类名 对象名（参数）；//定义对象的同时初始化
      类名 对象名=类名（参数）；

   2. 类名 *对象指针名=new 类名；
      类名 *对象指针名=new 类名()；
      类名 *对象指针名=new 类名（参数）；

2. 声明对象的引用

   1. 类名 &对象引用名 = 对象;

3. 声明对象指针

   1. 类名 *对象指针名 = 对象的地址;

4. 声明对象数组

   1. 类名 对象数组[数组大小];

5. 例：定义了类C后，可以有如下的声明：
   C a1,b1;//定义了C类的对象al和bl
   C *p=&a1;//定义了指向对象al的C类类型的指针p
   C &R=b1;//定义了C类类型对象bl的引用R
   C A[3]://定义了C类类型对象的数组A,含3个元素

### 第五节 访问对象成员

#### 一、使用对象访问成员变量与调用成员函数

1. 对象访问成员变量的格式：
   1. 对象名.成员变量名
2. 通过对象的指针访问成员变量的格式：
   1. 对象的指针->成员名
3. 通过对象的引用访问成员变量的格式：
   1. 对象的引用.成员变量名
4. 调用成员函数的格式：
   1. 对象名.成员函数名（参数表）
   2. 对象的指针->成员函数名（参数表）
   3. 对象的引用.成员函数名（参数表）

### 第六节 类成员的可访问范围

#### 一、访问范围活命符的含义

1. private是完全私有的，只有本类内可以访问，派生类和外部都不可以访问；
2. protected是受保护的，只有本类内和派生类可以访问，外部不能访问；
3. public内、外部都能访问；

#### 二、隐藏的作用

设置私有成员的机制叫做隐藏

“隐藏”的优点

1. 有利于程序的修改
2. 可以避免对对象的不正确操作

### 第七节 标识符的作用域与可见性

C++中标识符的作用域有函数原型作用域、局部作用域块作用域)、类作用域和命名空间作用域。

1. 函数原型作用域：在声明函数原型时形参的作用范围就是函数原型作用域，这是C++程序中最小的作用域。
   例：double ares(double r);
   r的作用范围就在函数area形参列表的左右括号之间。
2. 局部作用域：程序中使用相匹配的一对大括号括起来的一段程序称为块。作用域局限在块内的称为局部作用域。
   具有局部作用域的变量也称为局部变量。
3. 类作用域
   设：m是类X的成员，x是类X的对象，ptr是指向类X的一个对象的指针。则对m的访问方式有如下2种：
   1)类X的成员函数中可直接使用。（除非成员函数中有同名变量)。
   2)在类外，可以通过表达式x.m、X::m或者ptr->m来访问m。但注意不能违反m的访问修饰符的限定。
4. 命名空间作用域
   命名空间是为了消除程序各大模块之间同名引起的歧义。
   定义命名空间的一般形式如下：
   namespace 命名空间名
   {命名空间内的各种声明（函数声明、类声明、...）}
   在命名空间内部可以直接引用当前命名空间中声明的标识符，如果需要引用其他命名空间的标识符，需要使用下面的方式：
   命名空间名：标识符名
5. C++提供两种形式using语句：
   1)using命名空间名：标识符名；
   2)using namespace命名空间名；
   使用该语句后，可以在当前作用域中直接引用该命名空间内的任何标识符。
   例：using namespace std;
   具有命名空间作用域的变量也称为全局变量。

## 第三章 类和对象进阶

1. 设计并实现类的构造函数、析构函数
2. 创建类的对象，能定义并使用类的静态成员及常量成员
3. 正确使用常量成员与引用成员，能定义封闭类并能够进行正确的初始化。
4. 定义类的友元，使用this指针正确指代对象。

### 第一节 构造函数

#### 一、构造函数的作用

1. 构造函数是类中的特殊成员函数。
2. 构造函数的作用是完成对象的初始化。
3. 给出类定义时，由程序员编写构造函数。如果程序员没有编写类的任何构造函数，则由系统自动添加一个不带参数的构造函数。

#### 二、构造函数的定义

1. 构造函数在类体里的声明形式：
   类名（形参1，形参2，…形参n);//也可没有形参

2. 构造函数的定义形式：
   假设数据成员为x1,x2,xn,类体外定义构造函数时通常有3种形式：
   ①类名：：类名（形参1，形参2，…，形参n):x1(形参1），x2(形参2)，xn(形参n){}
   ②类名：类名（形参1，形参2，，形参n)
   {x1=形参1；
   x2=形参2；
   xn=形参n;
   }
   ③类名：类名()
   /成员变量所赋的初值都是固定的
   {x1=初始化表达式1；
   x2=初始化表达式2；
   xn=初始化表达式n;

3. 说明

   1. 构造函数的名字必须和类名相同；
   2. 在定义构造函数时不能指定返回类型，即不要返回值，即使是void类型也不可以；
   3. 另外类可有多个构造函数，即函数重载；或重载
   4. 构造函数的参数在排列时无顺序要求，只要保证相互对应即可；
   5. 构造函数可以使用默认参数。
   6. 在程序中说明一个对象时，程序自动调用构造函数来初始化该对象。

4. ```c++
   class myDate {
   public:
   	myDate();					//声明构造函数
   	myDate(int);				//声明构造函数
   	myDate(int, int);			//声明构造函数
   	myDate(int, int, int);		//声明构造函数
   
   private:
   	int year, month, day;		//成员变量
   };
   
   myDate::myDate() {							//构造函数用来初始化
   	year = 170, month = 1, day = 1;
   }
   myDate::myDate(int d) :year(1970), month(1) {	//带1个参数的
   	day = d;
   }
   myDate::myDate(int m, int d) :year(1970) {	//带2个参数的
   	month = m, day = d;
   }
   myDate::myDate(int y, int m, int d) {		//带3个参数的
   	year = y, month = m, day = d;
   }
   ```

#### 三、构造函数的使用

#### 四、复制构造函数与类型转换构造函数

1. 复制构造函数
   1. 复制构造函数是构造函数的一种，也称为拷贝构造函数。
   2. 复制构造函数的作用：使用一个已存在的对象去初始化另
   3. 一个正在创建的对象复制构造函数其原形为：
      类名：类名（类名&)//对象的引用作为形参
      或类名：类名(const类名&)
      /为了不改变原有对象，使用const限制。
   4. 如果类中没有给出复制构造函数，那么编译器会自动生成一个默认复制构造函数。
   5. 声明和实现复制构造函数的一般格式：
      class类名
      {public:
      类名（形参表）；
      //构造函数
      类名（类名 &对象名)；//声明复制构造函数
      };
      类名:：类名（类名 &对象名）//复制构造函数的实现
      {
      函数体}

### 第二节 析构函数

1. 析构函数和构造函数、复制构造函数都是构造型成员函数的基本成员；
2. 析构函数的作用是在对象消失时，释放由构造函数分配的内存；
3. 析构函数在类体里的声明形式：~类名()；
4. 析构函数的定义形式：类名：：~类名(){}
5. 类只能定义一个析构函数，且不能指明参数；
6. 如果程序中没有定义析构函数，则编译器自动生
7. 成默认的析构函，数默认析构函数的函数体为空
8. 使用new运算符动态分配了内存空间，则在析构函数中应该使用delete释放掉这部分占用的空间。
9. 当程序先后创建几个对象时，系统按照后建先析构的原则析构对象，当使用delete调用析构函数时,则按delete的顺序析构。
10. 析构函数在对象的生存期结束时被编译系统自动调用，然后对象占用的内存被回收。

### 第三节 类的静态成员

#### 一、静态变量

1. 静态变量根据变量定义的位置不同，分为静态全局变量和静态局部变量。

2. 静态全局变量：static修饰的、在所有花括号之外声明的变量，其作用域范围是全局可见的，即在整个项目文件内都有效。

3. 静态局部变量：static修饰的、块内定义的变量，其作用域从定义之处开始到本块结束处为止。静态变量均存储在全局数据区，静态局部变量只执行

4. 一次初始化。如果静态变量未初始化，则系统将其初始化为0。

5. ```c++
   ##include <iostream>
   using namespace std;
   static int glos=100;/静态全局变量
   ```

6. 跟java差不多

#### 二、类的静态成员

1. 类的静态成员有两种：静态成员变量和静态成员函数。
2. 定义静态成员：在类体内定义成员时，在前面加上statico
3. 静态成员变量不能在类体内赋值。给静态成员变量赋初值的格式如下：
4. 类型类名：静态成员变量=初值；/不能有static
5. 在类体外定义成员函数时，前面也不能加static.。
6. 类的静态成员被类的所有对象共享。
7. 静态函数与静态函数之间、非静态函数与非静态函数之间是可以相互调用的，非静态成员函数内可以调用静态成员函数，但静态成员函数内不能调用非静态成员函数。
8. 访问类静态成员的一般格式如下：
   类名：：静态成员名
   对象名.静态成员名
   对象指针->静态成员名
9. 静态成员与一般成员函数的不同
   1. 可以不指向某个具体的对象，只与类名连用；
   2. 在没有建立对象之前，静态成员就已存在；
   3. 静态成员是类的成员，不是对象的成员；
   4. 静态成员为该类的所有对象共享，它们被存储于一个公用内存中；
   5. 没有this指针，只能通过对象名或指向对象的指针访问类的数据成员；
   6. 静态成员函数不能被说明为虚函数；
   7. 静态成员函数不能直接访问非静态函数
10. 静态对象与普通对象的区别
    1. 静态对象的构造函数在代码执行过程中，在第一次遇到它的变量定义并初始化时被调用，但直到整个程结
       束之前仅调用一次；而普通对象则是遇到变量定义就被调用，遇到几次调用几次。
    2. 静态对象的析构函数在整个程序退出之前被调用，同样也只调用一次；而普通对象则是变量被定义几次，则析构几次。

### 第四节 变量及对象的生存周期的作用域

#### 一、变量的生存周期和作用域

1. 变量的生存期：是指变量所占据的内存空间由分配到释放的时期。
2. 变量的作用域：变量有效的范围。
3. 全局变量：是程序中定义在所有函数之外的变量。其作用域是程序从变量定义到整个程序结束的部分；其生存期为整个程序的执行期间。
4. 局部变量：在函数内或程序块内说明的变量。其作用域是函数体内或程序块内（一对大括号括起来的程序段）；其生存期为从被说明处开始，到所在函数或程序块结束处结束。

#### 二、类对象的生存周期和作用域

1. 类的对象在生成时调用构造函数，在消亡时调用析构函数，在这两个函数调用之间即是对象的生存期。
2. 类的对象的作用域和变量的作用域含义一致。

### 第五节 常量成员和常引用成员

1. 类常量成员变量

   1. 类常量成员变量：由关键字const修饰的类成员变量。
   2. 定义类常量成员变量的一般格式如下：
      1. const 数据类型 类常量成员变量=表达式；
   3. 类常量成员变量必须进行初始化，而且只能通过构造函数的成员初始化列表的方式进行。

2. 常量对象

   1. 常量对象：使用const声明的对象就是常对象
   2. 常量对象必须在声明的同时进行初始化，而且不能被更新。定义常量对象的一般格式：
      const 类名 对象名（参数表）；或
      类名const对象名（参数表）；
      例：myDate const al(1997,12,20);
      ∥定义myDate类常量对象al并初始化
   3. 常量对象只能调用常量成员函数，不能调用非常量函数，普通对象可以调用所有成员函数

3. 常量函数

   1. 常量函数：用constj声明、定义的成员函数。
   2. 常量函数的声明及定义形式为：
      1. 在类体内定义常量函数为内联函数时的形式：
         类型标识符 函数名（参数列表)const {...//函数体}
      2. 在类体内声明，类体外定义时的形式
         声明形式：类型标识符 函数名（参数列表）const;
         定义形式：类型标识符类名：函数名（参数列表)const
         {.../函数体}
      3. 常量函数不能更新对象的数据成员，也不能调用该类中没有用const修饰的成员函数

4. 常引用作为函数的参数
   使用引用作为函数参数，传送的是地址，所以形参改变，则实参也跟着改变，但如果不希望函数改变对象的
   值，就要使用常引用作为参数，
   例如：void Display(const doubled&r){cout<<r<<endl;}
   //Display只能使用而不能改变r所引用的对象。

   ```c++
   ##pragma once
   ##include <iostream>
   using namespace std;
   class Sample
   {
   public:
   	Sample();
   	void getVallue() const;	 //常量成员函数
   	void getValue();		 //非常量成员函数
   	void priValue();		 //非常量成员函数
   	void priVcon() const;	 //常量成员函数
   };
   
   
   
   
   ##include "Sample.h"
   Sample::Sample() {};			//构造函数
   void Sample::getVallue()const { //常量成员函数
   	cout << "常量函数成员" << endl;
   }
   void Sample::getValue() {		//非常量成员函数
   	cout << "非常量成员函数" << endl;
   }
   void Sample::priValue() {		// 非常量成员函数
   	cout << "非常量成员函数" << endl;
   }
   void Sample::priVcon()const {	// 常量成员函数
   	cout << "常量成员函数" << endl;
   }
   
   ##include <iostream>
   ##include "Sample.h"
   using namespace std;
   
   int main()
   {
   	const Sample cono;
   	Sample o;
   	cout << "cono\t";
   	cono.getVallue();	//通过常量只能调用常量成员函数
   	//cono.priValue();	// 编译错误
   	cout << "o/t";
   	o.getVallue();		//同名系统自动调用区别
   	cout << "o/t";
   	o.priValue();		//调用普通函数
   	cout << "o/t";
   	o.priVcon();		// 调用常成员函数
   
   
   	cout << "Hello World!\n";
   	return 0;
   
   
   
   ```

   ```c++
   ##pragma once
   ##include <iostream>
   using namespace std;
   class constClass
   {
   	const int conMbr; //类中的常量成员变量
   	int Mbr;		//普通成员变量
   public:
   	constClass() :conMbr(0), Mbr(100) {
   		//类中定义的const成员变量必须在构造函数的初始化列表中进行初始化
   	}
   	constClass(int i) :conMbr(i) {
   		Mbr = 200; //初始化列表给出初始值
   	}
   	void printConst()
   	{
   		cout << "conMbr=" << conMbr << ",Mbr=" << Mbr << endl;
   	}
   	int getConst() {
   		cout << "调用非常量函数" << endl;
   		return conMbr;
   	}
   	int getConst() const {
   		cout << "调用量函数" << endl;
   		return conMbr;
   	}
   	int getValue() {
   		return Mbr;
   	}
   
   	void processConst() {
   		cout << "-在processConstE函数中非常量-" << endl;
   		int x = 2 * conMbr + 1;// 可以读取conMbr
   		cout << "x=2*conMbr+1=" << x << endl;
   		//conMbr++;	//错误！不能更改常量成员变量conMbr的值
   		Mbr++;		// 可以修改非常量Mbr的值
   		cout << "Mbr=" << Mbr << endl;
   	}
   	void processConst() const {
   		cout << "-在processConst函数中常量-" << endl;
   		int x = conMbr + 1;
   		cout << "x=conMbr-+l=" << x << endl; // 可以读取conMbr
   		//conMbr++;	// 错误！不能更改常量成员变量conMbr的值
   		//Mbr++;		// 错误！也不能更改非常量成员变量Mbr的值
   		cout << "Mbr=" << Mbr << endl;
   	}
   
   };
   
   
   ```
   
   

### 第六节 成员对象和封闭类

#### 成员对象和封闭类的概念

1. 一个类的成员变量如果是另一个类的对象，则该成员变量称为“成员对象”。这两个类为包含关系。包含成
   员对象的类叫作封闭类。
2. 程序2-2中定义的类Student和类myDate,类Student中的成员变量birthday:是类my Date的对象，birthday?就是成员对象，Student是封闭类。

#### 一、封闭类构造函数的初始化列表

1. 在定义封闭类的构造函数时，需要添加初始化列表，指明要调用成员对象的哪个构造函数。在封闭类构造函数中添加初始化列表的格式如下：
2. 封闭类名：构造函数名（参数表)：成员变量1（参数表)，成员变量2（参数表)，
   {..}
   Student::Student(string n):name(n),birthday(myDateO)
   {}
3. 执行封闭类的构造函数时，先执行成员对象的构造函数，然后再执行本类的构造函数。
4. 封闭类对象生成时，先执行所有成员对象的构造函数，然后执行封闭类自己的构造函数。
5. 成员对象构造函数的执行次序与成员对象在类定义中的说明次序一致，与它们在构造函数初始化列表中出现的
   次序无关。
6. 当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后析构

#### 二、封闭类的复制构造函数

如果封闭类的对象是用默认复制构造函数初始化的，那么它包含的成员对象也会用复制构造函数初始化。

### 第七节 友元

#### 一、友元

1. 友元是为了兼顾C语言程序设计的习惯与C++信息隐藏的特点，而特意增加的功能。
2. 友元机制是对一些类外的函数打开的一个特殊通道，授权它们能够访问本类的私有成员变量。
3. 友元的概念破坏了类的封装性和信息隐藏，但有助于数据共享，能够提高程序执行的效率。
4. 友元机制包括友元函数和友元类。

#### 二、友元函数

1. 友元函数：在定义一个类的时候，可以把一些函数(包括全局函数和其他类的成员函数)声明为“友元”
   这样那些函数就成为本类的友元函数。
2. 在类定义中声明友元函数形式：
   friend函数类型函数名（参数列表)；//针对全局函数
   friend函数类型函数所在类名：函数名（参数列表)；
3. 友元函数可在类中的私有或公有部分通过关键字friend声明或定义，但如在类中声明，而在类外定义，就不能再在类外使用friend关键字。
4. 友元函数应被看作类的接口的一部分，使用它的主要目的是提高效率，因为它可以直接访问对象的私有成员，从而省去调用类的相应成员函数的开销。
5. 友元函数的另一个优点是：类的设计者不必在考虑好该类的各种可能使用情况之后再设计这个类，而是可以根据需要，通过使用友元来增加类的接口。

#### 三、友元类

1. 如果将一个类B说明为另一个类A的友元类，则类B中的所有函数都是类A的友元函数。
2. 在类定义中声明友元类的格式如下：
   1. friend class类名：
3. 友元类的关系是单向的。若说明类B是类A的友元类，不等于类A也是类B的友元类。友元类的关系不能传递即若类B是类A的友元类，而类C是类B的友元类，不等于类C是类A的友元类。
4. 除非确有必要，一般不把整个类说明为友元类，而仅把类中的某些成员函数说明为友元函数。

### 第八节 this指针

#### 一、this指针的实际形式

例如：成员函数Setxy(inta,
int b)
{x=a;y=b;}
当执行A.Setxy(25,55)时，为了确保正确赋值，成员
函数Setxy(inta,intb)实际上是如下形式：
void Point:Setxy (int a,int b)
/此时成员函数的this指针指向对象A。
{
this->x=a;
this->y=b;
}
注意：除非形参的名字与成员变量的名字相同，一般情况
下都省略掉符号“his->”，而让系统进行默认设置。

#### 二、this指针的概念和作用

1. C+十规定，当一个成员函数被调用时，系统将自动向它传递一个隐含的参数，该参数是一个指向调用该函数的对象的指针，名为ths指针，从而使成员函数知道该对哪个对象进行操作。
2. 使用tis指针，保证了每个对象可以拥有自己的数据成员，但处理这些数据成员的代码却可以被所有的对象共享，从而提高了程序的安全性和效率。
3. this指针是C++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起，从而在外部看来，每个对象都拥有自己的成员函数。
4. this指针指向的是成员函数作用的对象，也就是调用成员函数的对象。友元函数不通过对象调用，所以没有
   this指针。
5. 静态成员是类具有的属性，不是对象的特征，hs表示的是隐藏的对象的指针，所以静态成员函数没有ths指针。

## 第四章 运算符重载

### 第一节 运算符重载的概念

#### 一、重载运算符的概念

1. 运算符重载：给已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时产生不同的行为。
2. 运算符重载的目的是使得C++中的运算符也能够用来操作对象。
3. 可重载的运算符列在表4-1中，绝大多数运算符都可重载。
4. 不可重载的运算符及符号列在表4-2中，一共7种。要记住这7种运算符。
5. 运算符重载的实质是编写以运算符为名称的函数，使用运算符的表达式就被解释为对重载函数的调用。
6. 运算符函数的格式如下：
   返回值类型
   operator:运算符（形参表）
   [函数体
   函数名
7. 运算符可以被重载为全局函数（通常为类的友元函数，全局函数不能访问类的私有成员)，对于二元运算符，需要传递两个参数。
8. 运算符可以被重载为类的成员函数，对于二元运算符，只需要传递一个参数。

#### 二、重载运算符为成员函数

#### 三、重载运算符为友元函数

#### 四、重载运算符的规则

1. 重载后运算符的含义应该符合原有的用法习惯。例如，重载+”运算符，完成的功能就应该类似于做加法，在重载的+”运算符中做减法是不合适的。
2. 运算符重载不能改变运算符原有的语义，包括运算符的优先级和结合性。
3. 运算符重载不能改变运算符操作数的个数及语法结构。
4. 不能创建新的运算符，即重载运算符不能超出C++语言允许重载的运算符范围。
5. 重载运算符"0”““->”或者赋值运算符“=时，只能将它们重载为成员函数，不能重载为全局函数。
6. 运算符重载不能改变该运算符用于基本数据类型对象的含义。重载的运算符可以用于用户自定义类型的对象之间的运算，也可以用于用户自定义类型的对象与基本数据类型对象之间的混合运算。

### 第二节 重载赋值运算符

#### 一、重载赋值运算符

用于类运算的运算符通常都要重载。但有两个运算符，系统提供了默认的重载版本。

1. 赋值运算符=：系统默认重载为对象成员变量的复制。
2. 地址运算符&：系统默认重载为返回任何类对象的地址。
   例如：c1和c2都是复数类的对象
   c1=c2;//合法，系统默认的重载赋值运算
   c1=7;//错误，数据类型不同，需要编写相应重载赋值运算符的函数。

关于重载赋值运算符应该注意以下两点。

1. 赋值运算符必须重载为成员函数，不能重载为友元函数。
2. 为了保持与通常意义下的赋值运算符的功能相一致，应该让重载的赋值运算符仍然能连续使用，
   即res=cl=c2;”应成立。所以operator=函数通常要返回引用，具体到本例中，返回值类型是
   myComplex&。

#### 二、浅拷贝和深拷贝

1. 浅拷贝
   1. 浅拷贝：同类对象之间可以通过赋值运算符“=”互相赋值。如果没有经过重载，“=”的作用就是将赋值号右侧对象的值一一赋值给左侧的对象。这相当于值的拷贝，称为“浅拷贝”。
   2. 如果赋值的对象中涉及指针或是引用，则它们之间是互相关联的，一个值变化了，另一个值也跟着变化。因为对象中的指针指向的是同一个内存地址。

### 第三节 重载流插入运算符和流提取运算符

1. `<<`是流插入运算符，`>>`流提取运算符；
2. 头文件`include<iostream>`已经对这两个运算符进行了重载，用来输出C++基本数据类型。cout是ostream类的对象，cin是istream类的对象。
3. 程序员可以对这两个运算符进行重载，使之用于自定义的类对象。但重载函数不能是流类库中的成员，而必须重载为类的友元。
4. 重载流插入运算符的一般格式如下：
   ostream&operator`<<`(ostream&output,.类名&对象名)
   {../函数代码
   return output;
   1. output是类ostreami对象的引用，它是cout的别名。
   2. 插入运算符函数不改变对象的值，所以第二个参数类名&对象名”或“类名对象名”两种重载方式都是可以的。
5. 重载流提取运算符的一般格式：
   istream&operator>>(istream&input,.类名&对象名)
   {…//函数代码
   return input;
   1. input是类istream对象的引用，它是cin的别名；
   2. 提取运算符函数需要返回新的对象值，所以只能使用用，即“类名&对象名”，不能使用“类名对象名”

### 第四节 重载自增、自减运算符

## 第五章 类的继承与派生

1. 掌握基类、派生类的概念及两者之间的关系；
2. 能够声明具有继承关系的类；
3. 掌握派生和包含的设计方法；
4. 理解多重继承、多级派生等概念。
5. 解派生机制下构造函数和析构函数的调用次序。
6. 掌握对象、对象指针的具体含义。

### 第一节 类的继承与类的派生

#### 一、继承的概念

1. 类的派生是指从一个或多个以前定义的类产生新类的过程，原有的类称为基类，新产生的类称为派生类，基类所有的数据成员和成员函数。
2. 派生类继承了基类的除构造函数和析构函数外的所有成员变量和成员函数。
3. 派生类需要定义自己的构造函数和析构函数。
4. 相对基类，派生类可以有以下变化：增加新的成员；重新定义已有的成员函数；改变基类成员的访问权限
5. 派生类中定义了基类中同名的成员，则派生类的成员覆盖基类的同名成员。

#### 二、派生类的定义与大小

1. 派生类的定义
   class派生类名：继承方式说明符
   基类名
   {类体
   };
   继承方式说明符是指如何控制基类成员在派生类中的访
   问属性，通常是public,很少用protected和private。
2. 类的大小
   1. 派生类对象占用的存储空间大小，等于基类成员变量占用的存储空间大小加上派生类对象自身成员变量占用的存储空间大小，与成员函数和类中的静态成员变量无关。
   2. 为类对象分配空间时，遵循字节对齐的原则。
   3. 空类的大小是1

#### 三、继承关系的特殊性

1. 基类的友元不一定是派生类的友元；基类的成员函数是某类的友元函数，则其作为派生类继承的成员函数仍是某类的友元函数。
2. 基类中的成员是静态的，则在其派生类中，被继承的成员也是静态的。无论有多少个对象被创建，这些成员都只有一个拷贝，它为基类和派生类的所有对象所共享。
3. 派生类访问这些成员时，通常用<类名>::<成员名>的方式引用或调用。

#### 四、有继承关系的类之间的访问

1. 派生类中的成员函数可以访问基类中的公有成员，但不能直接访问基类中的私有成员。
2. 基类的成员和派生类新增的成员同名时，派生类成员优先，此时要是用基类同名成员，需要用<基类名>::<成员名>的方式引用或调用。

#### 五、protected访问范围说明符

1. 派生类可以直接访问基类中的保护成员。
2. 派生类不能直接访问基类中成员变量是私有成员。
3. 将基类部分成员设置为保护成员，既能起到隐藏的目的，又避免了派生类成员函数要访问它们时只能间接访问所带来的麻烦。
4. 派生类的成员函数只能访问所作用的那个对象（即his指针指向的对象)的基类保护成员，不能访问其他基类对象的基类保护成员。

#### 六、多重继承

1. 多重继承：一个派生类可以同时有多个基类。
2. 多重继承形式为：
   class派生类名：继承方式说明符基类名l,继承方式说明
   符基类名2，..，继承方式说明符基类名n
   {
   类体
   };
3. 二义性问题：多重继承时，如果多个基类中有重名的成员，则它们都被继承到派生类中。在这种情况下，访问重名成员时会遇到二义性问题。
4. 避免二义性方法，当要访问派生类对象中的某个变量时，添加“基类：”作为前缀，指明需要访问从哪个基类继承来的，从而可以排除二义性。
5. 如果基类中的成员均不同名，则派生类对象访问它们时不会出现二义性

### 第二节 访问控制

#### 一、类的兼容性规则

1. 在公有派生的情况下，有以下3条类型兼容规则。
   1. 派生类的对象可以赋值给基类对象。
   2. 派生类对象可以用来初始化基类引用。
   3. 派生类的指针可以赋值给基类的指针。
      上述3条规则反过来是不成立的。

#### 二、 私有继承的访问

​	

|                | 第一级派生类中   | 第二级别派生类中 | 基类与派生类外 |
| -------------- | ---------------- | ---------------- | -------------- |
| 基类的公有成员 | 直接访问         | 不可访问         | 不可访问       |
| 基类的保护成员 | 直接访问         | 不可访问         | 不可访问       |
| 基类的私有成员 | 调用公有函数访问 | 不可访问         | 不可访问       |

#### 四、保护继承

1. 保护继承中，基类的公有成员和保护成员都以保护成员的身份出现在派生类中，而基类的私有成员不可以直接访问。
2. 派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但在类外通过派生类的对象无法直接访问它们。

### 第三节 派生类的构造函数和析构函数

#### 一、派生类的构造函数和析构函数

1. 派生类并不继承基类的构造函数，所以需要在派生类的构造函数中调用基类的构造函数，以完成对从基类继承的成员变量的初始化工作。

2. 定义派生类构造函数的一般格式：
   派生类名：派生类名（参数表）：基类名1（基类1初始化参
   数表)，.，基类名m（基类m初始化参数表)，成员对
   象名1（成员对象1初始化参数表)，.，成员对象名n(
   成员对象n初始化参数表)
   {派生类构造函数函数体}//其他初始化操作

3. ```c++
   DerivedClass:DerivedClass(int m,int n,int k,int t):
   BaseClass1(m,n),BaseClass2(n,t),v3(k)
   {cout<<"DerivedClass带4个参数构造函数"<<endl;
   ```

4. 派生类构造函数执行的一般次序如下：

   1. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。
   2. 对派生类新增的成员变量初始化，调用顺序按照它们在类中声明的顺序。
   3. 执行派生类的构造函数体中的内容。

#### 二、复制构造函数

1. 对于一个类，如果程序中没有定义复制构造函数，则编译器会自动生成一个隐含的复制构造函数，这个隐含的复制构造函数会自动调用基类的复制构造函数，对派生类新增的成员对象一一执行复制。

#### 三、多重继承的构造函数与析构函数

1. 当创建有多个基类的派生类的对象时，按照类定义中给出的基类的顺序，依次调用它们的构造函数，再调用派生类的构造函数。对象消亡时，按照构造函数调用的次序的逆次序，调用析构函数。

### 第四节 类之间的关系

#### 一、类与类之间的关系

1. 使用已有类编写新的类有两种方式：继承和组合。
2. 类和类之间的两种基本关系：继承关系和组合关系(包含关系)
3. 继承关系也称为“is a”关系或“是”关系。是指在公有继承的赋值兼容规则下，如果类B公有继承于类A,在可以使用类A的对象的任何地方，则类B的对象同样也能使用，即每一个类B的对象“就是一个”类A的对象，但反之则不然，即如果需要一个类B的对象，则类A的对象就不行。
4. 组合关系也称为“has a”关系或“有”关系，表现为封闭类，即一个类以另一个类的对象作为成员变量。

#### 二、封闭类的派生

1. 封闭类：一个类的成员变量是另一个类的对象。
2. 定义封闭类构造函数的一般形式：
   类名：类名（形参表)：内嵌对象1（形参表），内嵌对象
   2(形参表)，..
   {类体
   }
   其中，“内嵌对象1（形参表)，内嵌对象2（形参表)，·
   ”是初始化列表，其作用是对内嵌对象进行初始化。
3. 在派生类也是封闭类的情况下，调用构造函数的顺序是：先根据派生层次从上至下依次执行所有基类的构造函数，最后执行自身的构造函数。如果某个类是封闭类，则在执行本类构造函数之前，先按照成员对象的定义顺序执行各个成员对象所属类的构造函数。
4. 而当派生类对象消亡时，执行析构函数的次序与执行构造函数的次序相反。

### 第五节 多层次派生

1. 派生可以是多层次的：类A派生类B,类B可以再派生类C,类C又能够派生类D,以此类推。在这种情况下，称类A是类B的直接基类，类B是类C的直接基类，类A是类C的间接基类。当然，类A也是类D的间接基类在定义派生类时，只需写直接基类，不需写间接基类。派生类沿着类的层次自动向上继承它所有的直接和间接基类的成员。
2. 在C++中，类之间的继承关系具有传递性。
3. 派生类的成员包括派生类自己定义的成员、直接基类中定义的成员及所有间接基类中定义的全部成员
4. 当生成派生类的对象时，会从最顶层的基类开始逐层往下执行所有基类的构造函数，最后执行派生类自身的构造函数：当派生类对象消亡时，会先执行自身的析构函数，然后自底向上依次执行各个基类的析构函数

### 第六节 基类与派生类指针的相互转换

1. 在公有派生的情况下，有以下3条类型兼容规则。
   1. 派生类的对象可以赋值给基类对象。
   2. 派生类对象可以用来初始化基类引用。
   3. )派生类的指针可以赋值给基类的指针，即基类指针指向派生类对象。
2. 基类的指针不能直接赋值给派生类的指针。但是通过强制类型转换，可以将基类指针强制转换成派生类指针后再赋值给派生类指针。
3. 即使基类指针指向一个派生类的对象，也不能通过基类指针访问基类中没有而仅在派生类中定义的成员函数。
4. 当使用指针调用类中的函数时，需要根据指针的类型来决定可调用的函数。
5. 如果一个指针是基类类型的，则不管它指向的是基类对象还是派生类对象，都仅能调用基类中声明的函数，而不能调用基类中没有声明而仅在派生类中声明的函数。
6. 如果一个指针是派类类型的，则调用的是派生类中的函数：如果派生类中没有声明，则调用从基类继承的同名函数。

## 第六章 多态与虚函数

1. 要求在了解多态、虚函数概念的基础上，掌握虚函数的定义方法；
2. 掌握实现多态的两种方式，能够给出多态程序的运行结果。
3. 掌握纯虚函数和抽象类的概念及实现方法。

### 第一节 多态的基本概念

#### 一、多态

1. 面向对象程序设计语言有封装、继承和多态3种机制，运用这3种机制能够有效提高程序的可读性、可扩充性和可重用性。
2. 多态：不同对象可以调用相同名称的函数，但可导致完全不同的行为的现象
3. 封装可以使得代码模块化，继承可以让程序在原有的代码基础上进行扩展，它们的目的都是为了代码复用。
4. 多态是为了接口复用，不论传递过来的是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。
5. 多态分为编译时多态和运行时多态
6. 编译时多态（静态多态）：在编译阶段就能绑定调用语句与调用函数入口地址，即函数的重载（包括运算符的重载)
7. 运行时多态（动态多态）：函数调用与代码入口地址的绑定需要在运行时刻才能确定，这也称为动态联编或动态绑定。
8. 运行时多态通过基类指针或基类引用调用虚函数。

#### 二、虚函数

1. 虚函数：在类的定义中使用virtual关键字来限定的成员函数即成为虚函数。
2. virtual关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。
3. 定义虚函数的一般格式：
   例：class A
   pubilic:
   virtual void fun();/声明虚函数
   };
   void A::fun (){.....}//定义虚函数
4. 关于虚函数，有以下几点需要注意。
   1. 虚函数一般不声明为内联函数。虽然将虚函数声明为内联函数不会引起错误，但因为内联函数是在编译阶段进行静态处理的，而对虚函数的调用是动态绑定的。
   2. 构造函数不能声明为虚函数。构造函数一般用来初始化对象，只有在一个对象生成之后，才能发挥多态作用。如果将构造函数声明为虚函数，则表现为在对象还没有生成的时候来定义它的多态，这两点是不统一的。另外，构造函数不能被继承，因而不能声明为虚函数。
   3. 静态成员函数不能声明为虚函数。静态成员函数对于每个类来说只有一份代码，所有的对象都共享这份代码，它不归某个对象所有，所以也没有动态绑定的必要性。
   4. 友元函数不能声明为虚函数。友元函数不属于类的成员函数，不能被继承，没有声明为虚函数的必要。
   5. 全局函数不能声明为虚函。虚函数是为了与继承机制配合实现多态的，而全局函数（非成员函数）不属于某个类，没有继承关系，只能被重载，不能被覆盖，声明为虚函数也起不到多态的作用。因此编译器会在编译时绑定全局函数。
   6. 派生类重写基类的虚函数实现多态，要求函数名、参数列表及返回值类型要完全相同。
   7. 基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性。
   8. 不要在构造函数和析构函数中调用虚函数。在构造函数和析构函数中，对象是不完整的，可能会出现未义
      的行为。
   9.  )最好将基类的析构函数声明为虚函数。

#### 四、通过基类的引用实现多态

1. 通过基类的引用调用基类和派生类中同名、同参数表的虚函数时，若其引用的是一个基类的对象，则调用的是基类的虚函数：若其引用的是一个派生类的对象，则调用的是派生类的虚函数。

### 第二节 多态实例

### 第三节 多态的使用

1. 通过基类的指针可以调用虚函数实现多态；
2. 通过基类的引用可以调用虚函数实现多态；(第一节讲了)
3. 通过普通成员函数（静态成员函数、构造函数和析构函数除外)中调用其他虚成员函数，并且是多态的。
4. 可以在构造函数和析构函数中调用虚函数。但这样调用的虚函数不是多态的

### 第四节 虚析构函数

1. C十十不支持虚构造函数，但支持虚析构函数。
2. 虚析构函数没有参数，没有返回值类型，声明虚析构函
   数的一般格式：
   virtual类名O;
3. 只要基类的析构函数被说明为虚函数，则派生类的析构函数，无论是否使用virtuali说明，都自动成为虚函数。
4. 使用虚析构函数的目的是为了在对象消亡时实现多态。具体来说，设置了虚析构函数后，在使用指针或引用时可以动态绑定，实现运行时的多态，保证使用基类类型的指针能够调用适当的析构函数针对不同的对象进行清理工作，以避免造成内存泄漏。

### 第五节 纯虚函数和抽象类

#### 一、纯虚函数

1. 纯虚函数是声明在基类中的虚函数，没有具体的定义，而由各派生类根据实际需要给出各自的定义。纯虚函数只有函数的名字但不具备函数的功能，不能调用基类中的这个函数。
2. 说明纯虚函数的一般形式为：
   virtual函数类型函数名（参数列表）=0；
   注意：必须有=0，不能有没有函数体，大括号也不能有；

#### 二、抽象类

1. 一个类可说明多个纯虚函数，包含纯虚函数的类称为抽象类。
2. 抽象类的派生类中，如果没有给出全部纯虚函数的定义，则派生类继续是抽象类。
3. 一个抽象类只能作为基类来派生新类，不能创建抽象类的对象，即抽象类不能实例化一个对象。
4. 可以定义抽象类的指针和引用。这样的指针和引用可以指向并访问派生类的成员，这种访问具有多态性。
5. 抽象类至少含有一个虚函数，而且至少有一个虚函数是
   纯虚函数，以便将它与空的虚函数区分开来，如下：
   virtual void area()=0;/纯虚函数
   virtual void area(){};/空的虚函数

## 第七章 输入/输出流

1. 理解并掌握输入/输出流类的基本概念；
2. 掌握标准流对象的基本概念和常见的标准流对象；
3. 掌握cin和cout重定向方法；
4. 掌握输入/输出流进行格式控制的常见方法；
5. 掌握常见的流操纵符和标志字，能够应用相关的方法完成I/0格式控制。
6. 掌握cin和cout中常见成员函数的基本功能和使用方法

## 第一节 流类简介

1. C++中没有输入/输出语句，输入和输出通过流完成。

2. 在C+的标准类库中，将与数据输入/输出相关的类统称为“流类”。C+中常用的几个流类及其关系如图所示。

3. 为了避免多重继承的二义性，从ios派生istream和ostream时，均使用了virtual关键字（虚继承）。

4. istream类提供了流的大部分输入操作，对系统预定义的所有输入流重载提取运算符">"。ostream类对系统预定义的所有输出流重载插入运算符"<<”

5. 常用I/O流类列表

   <table>
       <tr>
           <td colspan='2'>类名</td>
           <td>说明</td>
           <td>包含文件</td>
       <tr>
           <td>抽象流基类</td>
           <td>ios</td>
           <td>流基类</td>
           <td>ios</td>
       </tr>
       <tr>
           <td rowspan = '2'>输入流类</td>
           <td>istream</td>
           <td>通用输入流基类和其他输入流基类。<font color = 'red'>cin是该类的对象</font></td>
           <td>istream</td>
       </tr>
          <tr>
           <td>ifstream</td>
           <td>文件输入流类。<font color = 'red'>用一次从文件读取数据</font></td>
           <td>fstream</td>
       </tr>
       <tr>
           <td rowspan = '2'>输出流类</td>
           <td>ostream</td>
           <td>通用输出流基类和其他输出流基类。<font color = 'red'>cout是该类的对象</font></td>
           <td>ostream</td>
       </tr>
          <tr>
           <td>ofstream</td>
           <td>文件输出流类。<font color = 'red'>用于向文件写入文件</font></td>
           <td>fstream</td>
       </tr>
       <tr>
           <td rowspan = '2'>输入输出流类</td>
           <td>iosteam</td>
           <td><font color = 'red'>通用输入/输出流基类和其他输入/输出流基类</font></td>
           <td>iosteam</td>
       </tr>
          <tr>
           <td>fstream</td>
           <td>文件输入/输出流类<font color = 'red'>既能从文件中读取数据，也能向文件中写入数据</font></td>
           <td>fstream</td>
       </tr>
   </table>

6. C++的iostream类库常见的头文件有3个

7. iostream:包含操作所有输入/输出流所需的基本信息，

   1. iostream:包含操作所有输入/输出流所需的基本信息，因此大多数C++程序都应包含这个头文件。该文件含有4个标准流对象，提供了无格式化和格式化的/O功能。
   2. iomanip:包含格式化I/O的带参数流操纵符，可用于指定数据输入/输出的格式。
   3. fstream:包含处理文件的有关信息，提供建立文件、读写文件的各种操作接口。

## 第二节 标准流对象

1. 标准流对象（也称为标准流)：是为用户提供的常用外设与内存之间通信的通道，对数据进行解释和传输提供必要的数据缓冲等

2. C++在头文件iostream中定义了4个标准流对象：

   1. cin(标准输入流)：用于从键盘输入数据，是流类istream的对象。
   2. cout(标准输出流)：用于向屏幕输出数据，是流类ostream的对象，可以重定向输出到文件。
   3. cerr(非缓冲错误输出流)：cerr不使用缓冲区，直接向显示器输出信，不能重定向。
   4. clog（缓冲错误输出流)：先被存储到缓冲区中，缓冲区满或者刷新时才输出到屏幕。

3. cout可以使用重定向函数freopen:进行重定向输出到文件中保存。
   FILE *freopen(const char *path,const char *mode,FILE
   *stream);
   功能：是将stream按mode指定的模式重定向到路径path指向
   的文件。如果重定向时发生错误，则关闭原来的stream,函
   数返回NULL。mode可以是”w”(写)或T(读)方式。

   ```c++
   #include <iostream>
   using namespace std;
   int main(){
   int x,y;
   cin>>x >y;
   freopen("test.txt","w",stdout);∥将标准输出重定向到文件test.txt
   if (y==0)//除数为0则输出错误信息
   cerr<<"error."<<endl;
   else
   Cout<<x<<"/"<<y<<"="<<x/y<<endl;
   return 0;
   }
   
   #include <iostream>
   using namespace std:
   int main()
   int x,count,sum=0:
   freopen("input.dat","r",stdin);//将标准输入重定向到文件input.dat
   for(count=0;count<10;count++)
   ∥从输入流中读入10个整数进行处理
   {cin>>x;sum+=x;}
   cout<<"前1个整数的平均值="<l.0*sum/10<<endl;
   return 0;
   
   
   ```

4. C++在ios类中定义了<font color = 'red'>错误状态字</font>和<font color = 'red'>有关函数</font>

   | 标识常量 | 值   | 含义                            |
   | -------- | ---- | ------------------------------- |
   | goodbit  | 0X00 | 流状态正常                      |
   | eofbit   | 0X01 | 文件结束符                      |
   | failbit  | 0X03 | I/O操作失败，数据未丢失，可恢复 |
   | badbit   | 0X04 | 非法操作，数据丢失，不可恢复    |

   1. int eof()const;
      功能：测试是否到达文件尾，当文件操作结束遇到文件尾时，函数返回1：否则返回0。
      在标准输入流cin中，可以通过按下〈Ctr+Z〉组合键表示输入流的结束。
   2. int fail() const;
      功能：判断流操作是否失败。失败返回1，否则返回0。
   3. int good () const;
      int operator void *()
      功能：上述两个函数的功能相似，如果eofbit、failbit和badbit全部都没有被置位（即均为0），则返回1（流正常），否则返回0。
   4. int bad()const;
      int operator void!();
      上述两个函数的功能相似，只要eofbit、failbit和badbit中有一位被置位（即为1），则返回1（流失败），否则返回0。
   5. int rdstate0 const;
      功能：返回流的当前状态。
   6. void clear(int nStata=0);
      功能：恢复或设置状态字，即将流状态恢复为正常。

## 第三节 控制I/o格式

### 一、流操作符

1. C++进行/O格式控制的方式一般有使用流操纵符、设置标志字和调用成员函数。

2. C++在iostream中提供了一些常用的无参数的流操纵符(也称为格式控制符)

   | 流操纵符 | 作用                         | 输入/输出 |
   | -------- | ---------------------------- | --------- |
   | endl     | 输出一个新行符，并清空流     | O         |
   | ends     | 输出字符串结束，并清空流     | O         |
   | flush    | 清空流缓冲区                 | O         |
   | dec*     | 以十进制形式输入或输出整数   | I/O       |
   | hex      | 以十六进制形式输入或输出整数 | I/O       |
   | oct      | 以八进制形式输入或输出整数   | I/O       |
   | ws       | 提取空白字符                 | O         |

3. dec*的星号“*”不是操纵符的一部分，表示是默认设置。在默认情况下整数采用十进制形式输出

4. 在头文件iom㎡anip中定义了一些用于格式控制的流操纵符

## 第四节 调用cout成员函数

## 第五节 调用cin成员函数

# 第八章 文件操作

1. 理解并掌握文件的基本概念；
2. 掌握ifstream、ofstreami和fstream中常用的流函数；
3. 掌握对文本文件和二进制文件进行操作的基本方法；
4. 掌握文件读写指针的概念和移动文件指针的方法；
5. 能够使用文件完成综合应用。

## 第一节 文件基本概念和文件流类

### 一、文件的概念

1. C++根据文件数据的编码方式不同分为文本文件和二进制文件。
   1. 文本文件：文件中的每个字节都是一个ASCI I码。
   2. 二进制文件：C+中将非文本文件统称为二进制文件。
2. 根据存取方式不同分为顺序存取文件和随机存取文件。
   1. 顺序存取文件：就是按照文件中数据存储次序进行顺序操作。
   2. 随机访问文件：是根据应用的需要，通过命令移动位置指针直接定位到文件内需要的位置并进行数据操作。
3. 对文件的基本操作分为读文件和写文件。
   读文件：是将文件中的数据读入内存之中，也称为
   “输入”。
   写文件：就是将内存中的数据存入文件之中，也称为
   “输出”。

### 二、C++文件流

1. C++标准类库中有3个流类可以用于文件操作，这3个类统称为文件流类，分别如下：
2. ifstream:用于从文件中读取数据。
3. ofstream:用于向文件中写入数据。
4. fstream:既可用于从文件中读取数据，又可用于向文件中写入数据。
   使用这3个流类时，程序中需要包含fstream头文件。

## 第二节 打开和关闭文件 

### 一、打开文件

1. 打开文件有以下两个目的：
   1. 建立关联。通过指定文件名，建立起文件和文件流对象的关联。
   2. 指明文件的使用方式和文件格式。使用方式有只读、只写、既读又写、在文件末尾追加数据4种，文件格式是文本方式或二进制方式。
2. 打开文件的方式有以下两种。
   1. 先建立流对象，然后调用open()函数连接外部文件。格式如下：流类名对象名；
      对象名.open(文件名，模式)；
   2. 调用流类带参数的构造函数，在建立流对象的同时连接外部文件。格式如下：
      流类名对象名（文件名，模式）；

### 二、关闭文件

## 第三节 文件读写操作

### 一、读写文本文件

当一个文件操作完毕应及时关闭文件。其作用：

1. 系统会将缓冲区中的数据完整地写入文件，
2. 添加文件结束标记
3. 切断流对象与外部文件的连接。
   例如：关闭打开的文件
   ifstream inFile;
   inFile.open(nfile.txtH,ios:in);//打开文件"file.txt
   inFile.close();
   //关闭文件

### 二、读写二进制文件

1. 文本文件
   1. 以ASCⅡ码形式保存数据的，存储信息时占用的空间较大。
   2. 使用上比较方便，“记事本”软件打开后查看、编辑文件内容等；
   3. 在进行数据输入/输出时需要要额外进行内存和外存之间的数据格式转换。
2. 二进制数据文件
   1. 以二进制形式存放，即二进制文件中数据的存储格式与内存格式一致，存储长度仅与数据类型相关。
   2. 二进制数据流不会对写入或读出的数据做格式转换，便于高速处理数据。
3. 读写二进制文件的专用函数
   1. ostream write(char buffer,int nCount):
      功能：该成员函数将内存中buffer所指向的nCount个字节的内容写入文件，返回值是对函数所作用的对象的引用。
   2. istream &read(char buffer,int nCount);
      功能：从文件中读取nCount个字节的内容，存放到buffer所指向的内存缓冲区中，返回值是对函数所作用的对象的引用
   3. int gcountO);
      功能：返回值就是最近一次read()函数执行时成功读取的字节数。

### 三、用成员函数put()和get()读写文件

1. 函数get()有3种主要形式：
   1. int get()函数
      功能：从指定的输入流中提取一个字符，当遇到文件结束符时，返回系统常量EOF。
   2. istream get(char &rch);
      功能：从指定输入流中提取一个字符，将该字符作为rch
      引用的对象。当遇到文件结束符时，函数返回0：否则返回
      对istream对象的引用。
   3. istream&get(char *pch,int nCount,char delim="\n");
      功能：从流的当前字符开始，读取nCount-1个字符，或遇到指定的分隔符delim结束。函数把读取的字符（不包括分隔符)写入数组pch中，并在字符串后添加结束符'\0'
2. 函数put()的语法格式如下：
   ostream& put(char ch);
   功能：向输出流中插入一个字节。
3. 成员函数getO和putO常用于读写字符或文本文件，也可用于二进制文件的处理。

### 四、文本文件与二进制文件的异同

1. 文本文件是以文本形式存储数据
   优点：是具有较高的兼容性。
   缺点：
   1. 是存储一批纯数值信息时，要在数据之间人为地添加分隔符
   2. 在输入/输出过程中，系统要对内外存的数据格式进行相
   3. 不便于对数据进行随机访问。
2. 二进制文件是以二进制形式存储数据
   1. 优点：
      1. 相同数据类型的数据所占空间的大小均是相同的，不必在数据之间人为地添加分隔符；
      2. 在输入/输出过程中，系统不需要对数据进行任何转换。
      3. 便于对数据实行随机访问。
   2. 缺点：数据兼容性差。
3. 通常纯文本信息（如字符串)以文本文件形式存储，而将数值信息以二进制文件形式存储。
4. 文本文件和二进制文件在处理上和使用上有微小差别。

## 第四节 随机访问文件

1. 顺序文件：只能进行顺序存取操作的文件。如：键盘、显示器和保存在磁带上的文件。
2. 随机文件：可以在文件的任意位置进行存取操作文件。如：磁盘文件。
3. 顺序访问：严格按照数据保存的次序从头到尾访问文件
4. 随机访问：根据需要在文件的不同位置进行访问。
5. 顺序文件只能进行顺序访问；随机文件既可以进行顺序访问，也可以进行随机访问。
6. 文件位置指针：文件打开后，系统自动生成一个流指针，这个指针决定着写或读开始的位置。
7. 打开文件时，位置指针指向文件的第1个字节（如果以ios:ate方式打开，则指向文件末尾)，文件的读/写操作从位置指针所指位置开始，每完成一次读/写操作后，位置指针自动移动到下一个读/写分量的起始位置。
8. 类istream中与位置指针相关的函数如下：、
   1. 移动读指针函数：
      istream seekg(long pos);
      功能：将读指针设置为pos,即将读指针移动到文件的pos字节处。
      istream seekg(long offset,ios::seek dir dir);
      功能：是将读指针按照seek dir的指示（方向)移动offset个字节。其中seek dir是在类ios中定义的一个枚举类型。
      1. seek dir的常量值含义如下：
      2. ios::beg:表示流的开始位置。
      3. ios::cur:表示流的当前位置。
      4. ios：：end:表示流的结束位置。
         例：input.seekg(20,ios:beg);
         //以流开始位置为基准，后移20个字节
         input.seekg(-10,ios::cur);
         /以流指针当前位置为基准，前移10个字节
         input.seekg(-10,ios::end);
         以流结尾位置为基准，前移10个字节
         可见，函数seekg(n)等价于：seekg(n,ios::beg)
   2. 返回读指针当前位置值的函数
      long tellg()
      功能：函数返回值值为流中读指针的当前位置。
9. 类ostream中与位置指针相关的函数如下：
   1. 移动写指针函数
      ostream seekp (long pos);
      功能：将写指针设置为pos,即将写指针移动到文件的pos字节处。
      ostream seekp (long offset,ios::seek dir dir);
      功能：将写指针按seek dir指示的方向移动offset个字节。
   2. 返回写指针当前位置的函数
      long tellp();
      功能：函数返回值值为流中写指针的当前位置。
10. inFile.clear(:/将流恢复为正常状态。必不可少
    inFile,seekg(O);/将文件读指针移动到文件起始位置
    cout<<"位置指针："<inFile..tellgO<<endl;

# 第九章 函数模板与类模板 

1. 能够定义函数模板和类模板
2. 能够使用函数模板及类模板实现相关的程序。

## 第一节 函数模板

## 一、函数模板的概念

1. 函数模板：在程序设计时不给出相应数据的实际类型，而是将类型参数化，在实际编译时，才由编译器利用实际的类型给予实例化，使它满足需要，就像按照模板来制造新的函数一样，这样的函数就是函数模板。

2. 将函数模板与某个具体数据类型连用，就产生了模板函数，又称这个过程为函数模板实例化。函数模板实例化的过程由编译器完成。

3. 在调用函数模板时，函数参数的类型决定到底使用模板的哪个版本，即模板的参数是由函数的参数推断出来的。

4. 定义函数模板的一般格式如下：
   template<类型参数名，类型参数名，--〉
   返回类型名 函数模板名（参数表）
   {函数体的定义}
   说明：“类型 参数名”可以是以下2种。

   1. 类型由class(或typename.)标识符，指明函数模板中可以接收的类型参数，参数名由标识符表示。
   2. 类型说明符标识符，指明函数模板中可以接收一个由类型说明符”所规定类型的常量作为参数。

   ```c++
   #include <iostream>
   using namespace std;
   template<typename T>//函数模板
   T abs (T x)
   {return x<0?-x:x;}
   int main()
   {int n=-5;int m=10;
    double d=-.5;float f=3.2;
    cout<<n<<"的绝对值是："<<abs(n)<<endl;
   //编译器自动生成int abs(intx){return x<0?-x:x;}函数
   cout<<m<"的绝对值是："<<abs(m)<<endl;
   cout<<d<"的绝对值是："<<abs(d)<<endl;
   cout<<f<"的绝对值是："<abs(f)<<endl;
   return 0;
   }
   ```

   函数模板的使用形式与函数类似，但二者有本质的区别，主要表现在以下3个方面：

   1. 函数模板本身在编译时不会生成任何目标代码，只有当通过模板生成具体的函数实例时才会生成目标代码。
   2. 被多个源文件引用的函数模板，应当连同函数体一同放在头文件中，而不能像普通函数那样只将声明放在头文件中。
   3. 函数指针也只能指向模板的实例，而不能指向模板本身

5. 生成模板函数的过程：
   编译器由函数模板自动生成模板函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参类型判断该如何替换模板中的类型参数。

### 二、函数或函数模板调用语句的匹配顺序

1. 函数可以重载，函数模板也可以重载重载的
2. 函数与函数模板也是允许重载的。在函数和函数模板名字相同的情况下，一条函数调用语句到底应该被匹配对哪个函数或哪个模板的调用呢？C++编译器遵循以下先后顺序：
   1. 先找参数完全匹配的普通函数（不是由模板实例化得到的模板函数)。
   2. 再找参数完全匹配的模板函数。
   3. 然后找实参经过自动类型转换后能够匹配的普通函数。
   4. 如果上面的都找不到，则报错。

## 第二节 类模板

### 一、类模板的概念

1. 类是对一组对象的公共性质的抽象，而类模板则是对不同类的公共性质的抽象。
2. 使用泛型数据类型替代实际的数据类型来说明成员变量，从而定义一个泛型类。这相当于定义一个类的模板。
3. 类模板需要一种或多种类型参数，所以也称为参数化类。
4. 类是相同类型事物的抽象，有继承关系的类可以具有不同的操作。类模板是不同类型的事物具有相同的操作，实例化后的类之间没有联系，相互独立。
5. 声明类模板的一般格式如下：
   template<模板参数表>
   class类模板名
   {类体定义}
   其中：①template为关键字
   ②<类模板参数>通常格式为<class T>或<typename T>。
   ③
   类模板与函数模板的声明方法及参数格式是相同的，不
   同的是在类模板参数表之后还有类声明。
6. 类模板的成员函数可以在类体内进行说明，自动成为内联函数。在类模板以外定义其成员函数，则要采用以下
   格式。
   template<模板参数表>
   返回类型名
   类模板名<模板参数标识符列表>：成员函
   数名（参数表)
   {函数体
   }
   类模板声明本身并不是一个类，它说明了类的一个家族。只有当被其他代码引用时，模板才根据引用的需要生成具体的类。
